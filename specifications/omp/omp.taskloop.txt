omp.taskloop (omp::TaskloopOp) ¶
Taskloop construct

Syntax:

operation ::= `omp.taskloop` oilist(
              `allocate` `(`
              custom<AllocateAndAllocator>($allocate_vars, type($allocate_vars),
              $allocator_vars, type($allocator_vars)) `)`
              |
              `final` `(` $final `)`
              |
              `grainsize` `(` $grainsize `:` type($grainsize) `)`
              |
              `if` `(` $if_expr `)`
              |
              `mergeable` $mergeable
              |
              `nogroup` $nogroup
              |
              `num_tasks` `(` $num_tasks `:` type($num_tasks) `)`
              |
              `priority` `(` $priority `:` type($priority) `)`
              |
              `untied` $untied
              )
              custom<InReductionPrivateReductionRegion>(
              $region, $in_reduction_vars, type($in_reduction_vars),
              $in_reduction_byref, $in_reduction_syms, $private_vars,
              type($private_vars), $private_syms, $reduction_vars,
              type($reduction_vars), $reduction_byref, $reduction_syms) attr-dict
The taskloop construct specifies that the iterations of one or more associated loops will be executed in parallel using explicit tasks. The iterations are distributed across tasks generated by the construct and scheduled to be executed.

The body region can only contain a single block which must contain a single operation. This operation must be another compatible loop wrapper or an omp.loop_nest.

omp.taskloop <clauses> {
  omp.loop_nest (%i1, %i2) : index = (%c0, %c0) to (%c10, %c10) step (%c1, %c1) {
    %a = load %arrA[%i1, %i2] : memref<?x?xf32>
    %b = load %arrB[%i1, %i2] : memref<?x?xf32>
    %sum = arith.addf %a, %b : f32
    store %sum, %arrC[%i1, %i2] : memref<?x?xf32>
    omp.yield
  }
}
For definitions of “undeferred task”, “included task”, “final task” and “mergeable task”, please check OpenMP Specification.

When an if clause is present on a taskloop construct, and if the if clause expression evaluates to false, undeferred tasks are generated. The use of a variable in an if clause expression of a taskloop construct causes an implicit reference to the variable in all enclosing constructs.

The allocator_vars and allocate_vars parameters are a variadic list of values that specify the memory allocator to be used to obtain storage for private values.

When a final clause is present and the final clause expression evaluates to true, the generated tasks will be final tasks. All task constructs encountered during execution of a final task will generate final and included tasks. The use of a variable in a final clause expression causes an implicit reference to the variable in all enclosing constructs.

If a grainsize clause is present, the number of logical loop iterations assigned to each generated task is greater than or equal to the minimum of the value of the grain-size expression and the number of logical loop iterations, but less than two times the value of the grain-size expression.

When the mergeable clause is present, the tasks generated by the construct are “mergeable tasks”.

By default, the taskloop construct executes as if it was enclosed in a taskgroup construct with no statements or directives outside of the taskloop construct. Thus, the taskloop construct creates an implicit taskgroup region. If the nogroup clause is present, no implicit taskgroup region is created.

If num_tasks is specified, the taskloop construct creates as many tasks as the minimum of the num-tasks expression and the number of logical loop iterations. Each task must have at least one logical loop iteration.

The priority clause is a hint for the priority of the generated tasks. The priority is a non-negative integer expression that provides a hint for task execution order. Among all tasks ready to be executed, higher priority tasks (those with a higher numerical value in the priority clause expression) are recommended to execute before lower priority ones. The default priority-value when no priority clause is specified should be assumed to be zero (the lowest priority).

Reductions can be performed by specifying reduction accumulator variables in reduction_vars, symbols referring to reduction declarations in the reduction_syms attribute, and whether the reduction variable should be passed into the reduction region by value or by reference in reduction_byref. Each reduction is identified by the accumulator it uses and accumulators must not be repeated in the same reduction. A private variable corresponding to the accumulator is used in place of the accumulator inside the body of the operation. The reduction declaration specifies how to combine the values from each iteration, section, team, thread or simd lane defined by the operation’s region into the final value, which is available in the accumulator after they all complete.

If the untied clause is present on a task construct, any thread in the team can resume the task region after a suspension. The untied clause is ignored if a final clause is present on the same task construct and the final expression evaluates to true, or if a task is an included task.

If an in_reduction clause is present on the taskloop construct, the behavior is as if each generated task was defined by a task construct on which an in_reduction clause with the same reduction operator and list items is present. Thus, the generated tasks are participants of a reduction previously defined by a reduction scoping clause. In this case, accumulator variables are specified in in_reduction_vars, symbols referring to reduction declarations in in_reduction_syms and in_reduction_byref indicate for each reduction variable whether it should be passed by value or by reference.

If a reduction clause is present on the taskloop construct, the behavior is as if a task_reduction clause with the same reduction operator and list items was applied to the implicit taskgroup construct enclosing the taskloop construct. The taskloop construct executes as if each generated task was defined by a task construct on which an in_reduction clause with the same reduction operator and list items is present. Thus, the generated tasks are participants of the reduction defined by the task_reduction clause that was applied to the implicit taskgroup construct.

Traits: AttrSizedOperandSegments, AutomaticAllocationScope, NoTerminator, RecursiveMemoryEffects, SingleBlock

Interfaces: BlockArgOpenMPOpInterface, ComposableOpInterface, LoopWrapperInterface, ReductionClauseInterface

Attributes: ¶
Attribute	MLIR Type	Description
in_reduction_byref	::mlir::DenseBoolArrayAttr	i1 dense array attribute
in_reduction_syms	::mlir::ArrayAttr	symbol ref array attribute
mergeable	::mlir::UnitAttr	unit attribute
nogroup	::mlir::UnitAttr	unit attribute
private_syms	::mlir::ArrayAttr	symbol ref array attribute
reduction_byref	::mlir::DenseBoolArrayAttr	i1 dense array attribute
reduction_syms	::mlir::ArrayAttr	symbol ref array attribute
untied	::mlir::UnitAttr	unit attribute
Operands: ¶
Operand	Description
allocate_vars	variadic of any type
allocator_vars	variadic of any type
final	1-bit signless integer
grainsize	integer or index
if_expr	1-bit signless integer
in_reduction_vars	variadic of OpenMP-compatible variable type
num_tasks	integer or index
priority	integer
private_vars	variadic of any type
reduction_vars	variadic of OpenMP-compatible variable type